## 正则表达式中的特别注意点

| /ab+/                                                        | +只影响最近的一个字符                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| /(ab)+/***\*加括号分组匹配\****                              | 分组之后影响的就是ab两个字符了                               |
| /(ab)c/去匹配str=’abc’                                       | 匹配会返归[‘abc’,’ab’]分组除了匹配外还会将括号里面的单独捕获出来 |
| 在***\*分组前面加?:\****表示不需要单独捕获括号里面的         | 例如![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps21.jpg)返回[‘abc’] |
| /(ab)cd\1/                                                   | 转义符加数字代表转译符的分组\1代表第一个分组\2代表第二个分组，可以在//中间用来代替第一次或第n次的分组 |
| RegExp.$1                                                    | var r= /^(\d{4})-(\d{1,2})-(\d{1,2})$/; //正则表达式 匹配出生日期(简单匹配)   r.exec('1985-10-15');s1=RegExp.$1;s2=RegExp.$2;s3=RegExp.$3;alert(s1+" "+s2+" "+s3)//结果为1985 10 15 |
| /\./                                                         | 匹配一个小数点                                               |
| /[^\n]/ 与 /./相等                                           | 不转义的小数点 匹配除换行符的所有字符                        |
| 正则表达式默认“贪婪匹配”                                     | 例如![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps22.jpg)会匹配出3个a |
| 正则表达式将“贪婪匹配”变成非贪婪匹配只需要***\*在后面加一个？\**** | 例如![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps23.jpg)会匹配出1个a但是![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps24.jpg)会匹配出aaab因为在跳进允许下尽可能少的匹配，但是会从第一个可以匹配的开始匹配 |
| 构造函数里面的转译字符需要双重转译                           | 例如![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps25.jpg) |
| 前瞻性匹配如果java后面是script就匹配出java                   | 例如![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps26.jpg) |
| 如果java后面不是script就匹配出java                           | 例如![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps27.jpg) |
| 正则表达式中的g、i、m                                        | g表示全局匹配、i表示忽略大小写、m表示多行匹配，多行匹配一定要和全局匹配和$首匹配^尾匹配结合起来用 |
| match是string下面的方法Exec是RegExp下面的方法                | ![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps28.jpg)![img](file:///C:\Users\qiwei\AppData\Local\Temp\ksohtml10204\wps29.jpg) |
| $0表示 非分组匹配到的内容                                    | ![img](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E7%82%B9.assets/wps30.jpg) |