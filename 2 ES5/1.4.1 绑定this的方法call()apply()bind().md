## 改变函数内部this指向call()、applay()、bind()区别

#### 1. Function.prototype.call()

将`f()`内部`this`指向`obj对象`

```js
var obj = {};
var f = function () {
	return this;
};
f() === window // true
f.call(obj) === obj // true
```

##### 1.1 `call`方法的参数，应该是一个对象。如果参数为空、`null`和`undefined`，则默认传入全局对象`window`

```js
var n = 123;
var obj = { n: 456 };
function a() {
    console.log(this.n);
}
a.call() // 123
a.call(null) // 123
a.call(undefined) // 123
a.call(window) // 123
a.call(obj) // 456
```

`call`方法还可以接受多个参数。

```js
func.call(thisValue, arg1, arg2, ...)
```

`call`的第一个参数就是`this`所要指向的那个对象，后面的参数则是函数调用时所需的参数。

```js
function add(a, b) {
    return a + b;
}
add.call(this, 1, 2) // 3
```
##### 1.2 call方法的一个应用（调用对象的原生方法）

```js
var obj = {};
obj.hasOwnProperty('toString') // false

// 覆盖掉继承的 hasOwnProperty 方法
obj.hasOwnProperty = function () {
  return true;
};
obj.hasOwnProperty('toString') // true

Object.prototype.hasOwnProperty.call(obj, 'toString') // false
```

上面代码中，`hasOwnProperty`是`obj`对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。`call`方法可以解决这个问题，它将`hasOwnProperty`方法的原始定义放到`obj`对象上执行，这样无论`obj`上有没有同名方法，都不会影响结果。



 #### 2. Function.prototype.apply()

`apply`方法的作用与`call`方法类似，也是改变`this`指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。

```js
func.apply(thisValue, [arg1, arg2, ...])
```

call()与apply()对比

```js
function f(x, y){
    console.log(x + y);
}
f.call(null, 1, 1) // 2
f.apply(null, [1, 1]) // 2
```

##### 2.1 应用，找出最大元素(如果参数为空、`null`和`undefined`，则默认传入全局对象`window`)

```js
var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
```

##### 2.2 将数组的空元素变为`undefined`

```js
var b = ['a',,17,,'sd'];
Array.apply(null, b); // 相当于window.Array(b) // 相当于Array(b);
```

空元素与`undefined`的差别在于，数组的`forEach`方法会跳过空元素，但是不会跳过`undefined`。因此，遍历内部元素的时候，会得到不同的结果。

##### 2.3 类数组对象转数组对象

```js
Array.prototype.slice.apply({0: 1, length: 1}) // [1]
Array.prototype.slice.apply({0: 1}) // []
Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]
Array.prototype.slice.apply({length: 1}) // [undefined]
```

这个方法起作用的前提是，被处理的对象必须有`length`属性，以及相对应的数字键。

##### 2.4 绑定回调函数的对象

```js
var o = new Object();
o.f = function () {
  console.log(this === o);
}
var f = function (){
  o.f.apply(o);
  // 或者 o.f.call(o);
};
// jQuery 的写法
$('#button').on('click', f);
```

上面代码中，点击按钮以后，控制台将会显示`true`。由于`apply()`方法（或者`call()`方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的`bind()`方法。